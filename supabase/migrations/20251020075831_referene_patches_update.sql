alter table "public"."reference_patches" drop constraint "ml_training_tiles_status_check";

drop function if exists "public"."get_clipped_geometries_batch"(p_label_id bigint, p_geometry_table text, p_bbox_minx double precision, p_bbox_miny double precision, p_bbox_maxx double precision, p_bbox_maxy double precision, p_buffer_m double precision, p_limit integer, p_offset integer);

drop index if exists "public"."idx_ref_patches_status";

create table "public"."reference_datasets" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "dataset_id" bigint
);


alter table "public"."reference_datasets" enable row level security;

alter table "public"."reference_patches" drop column "status";

alter table "public"."reference_patches" add column "deadwood_validated" boolean;

alter table "public"."reference_patches" add column "epsg_code" integer;

alter table "public"."reference_patches" add column "forest_cover_validated" boolean;

alter table "public"."reference_patches" add column "utm_zone" character varying(5);

CREATE INDEX idx_ref_patches_validation ON public.reference_patches USING btree (dataset_id, deadwood_validated, forest_cover_validated);

CREATE UNIQUE INDEX reference_datasets_pkey ON public.reference_datasets USING btree (id);

alter table "public"."reference_datasets" add constraint "reference_datasets_pkey" PRIMARY KEY using index "reference_datasets_pkey";

alter table "public"."reference_datasets" add constraint "reference_datasets_dataset_id_fkey" FOREIGN KEY (dataset_id) REFERENCES v2_datasets(id) not valid;

alter table "public"."reference_datasets" validate constraint "reference_datasets_dataset_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_clipped_geometries_batch(p_label_id bigint, p_geometry_table text, p_bbox_minx double precision, p_bbox_miny double precision, p_bbox_maxx double precision, p_bbox_maxy double precision, p_epsg_code integer, p_buffer_m double precision DEFAULT 2.0, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(geometry jsonb, total_count bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  bbox_geom GEOMETRY;
  bbox_box2d BOX2D;
  total_intersecting bigint;
BEGIN
  -- Create bbox geometry in UTM with buffer using provided EPSG code
  bbox_geom := ST_Transform(
    ST_MakeEnvelope(
      p_bbox_minx - p_buffer_m,
      p_bbox_miny - p_buffer_m,
      p_bbox_maxx + p_buffer_m,
      p_bbox_maxy + p_buffer_m,
      p_epsg_code
    ),
    4326  -- Transform to WGS84 for comparison with prediction geometries
  );

  -- Create BOX2D for faster clipping
  bbox_box2d := bbox_geom::box2d;

  -- Get total count (only on first batch)
  -- Count AFTER making valid, not before
  IF p_offset = 0 THEN
    EXECUTE format(
      'SELECT COUNT(*) FROM %I
       WHERE label_id = $1
       AND ST_Intersects(ST_MakeValid(geometry), $2)',
      p_geometry_table
    ) INTO total_intersecting USING p_label_id, bbox_geom;
  ELSE
    total_intersecting := 0; -- Don't recount on subsequent batches
  END IF;

  -- Process geometries - FIX invalid geometries FIRST, then clip
  RETURN QUERY EXECUTE format(
    'SELECT
      ST_AsGeoJSON(
        CASE
          WHEN ST_GeometryType(clipped_geom) = ''ST_GeometryCollection''
          THEN ST_CollectionExtract(clipped_geom, 3)
          ELSE clipped_geom
        END
      )::jsonb as geometry,
      $5 as total_count
    FROM (
      SELECT
        ST_ClipByBox2D(
          ST_MakeValid(geometry),  -- Fix invalid geometries
          $4
        ) as clipped_geom
      FROM %I
      WHERE label_id = $1
      AND ST_Intersects(ST_MakeValid(geometry), $2)  -- Use MakeValid in intersection check too
      ORDER BY id
      LIMIT $6
      OFFSET $7
    ) sub
    WHERE NOT ST_IsEmpty(clipped_geom)
    AND ST_GeometryType(clipped_geom) IN (''ST_Polygon'', ''ST_MultiPolygon'', ''ST_GeometryCollection'')',
    p_geometry_table
  ) USING
    p_label_id,
    bbox_geom,
    bbox_geom,
    bbox_box2d,
    total_intersecting,
    p_limit,
    p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_clipped_geometries_batch(p_label_id bigint, p_geometry_table text, p_bbox_minx double precision, p_bbox_miny double precision, p_bbox_maxx double precision, p_bbox_maxy double precision, p_utm_zone text, p_buffer_m double precision DEFAULT 2.0, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(geometry jsonb, total_count bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  bbox_geom GEOMETRY;
  bbox_box2d BOX2D;
  total_intersecting bigint;
  utm_epsg_code int;
BEGIN
  -- Calculate EPSG code from UTM zone (e.g., "32N" -> 32632, "33S" -> 32733)
  IF substring(p_utm_zone from '[NS]$') = 'N' THEN
    utm_epsg_code := 32600 + substring(p_utm_zone from '^[0-9]+')::int;
  ELSE
    utm_epsg_code := 32700 + substring(p_utm_zone from '^[0-9]+')::int;
  END IF;

  -- Create bbox geometry in UTM with buffer
  bbox_geom := ST_Transform(
    ST_MakeEnvelope(
      p_bbox_minx - p_buffer_m,
      p_bbox_miny - p_buffer_m,
      p_bbox_maxx + p_buffer_m,
      p_bbox_maxy + p_buffer_m,
      utm_epsg_code
    ),
    4326  -- Transform to WGS84 for comparison with prediction geometries
  );

  -- Create BOX2D for faster clipping
  bbox_box2d := bbox_geom::box2d;

  -- Get total count (only on first batch)
  -- Use ST_IsValid check to skip problematic geometries in count
  IF p_offset = 0 THEN
    EXECUTE format(
      'SELECT COUNT(*) FROM %I
       WHERE label_id = $1
       AND ST_IsValid(geometry)
       AND ST_Intersects(geometry, $2)',
      p_geometry_table
    ) INTO total_intersecting USING p_label_id, bbox_geom;
  ELSE
    total_intersecting := 0;
  END IF;

  -- Process geometries with validation BEFORE intersection check
  RETURN QUERY EXECUTE format(
    'SELECT
      ST_AsGeoJSON(
        CASE
          WHEN ST_GeometryType(clipped_geom) = ''ST_GeometryCollection''
          THEN ST_CollectionExtract(clipped_geom, 3)
          ELSE clipped_geom
        END
      )::jsonb as geometry,
      $5 as total_count
    FROM (
      SELECT
        ST_ClipByBox2D(
          -- Always validate to prevent topology exceptions
          ST_MakeValid(geometry),
          $4
        ) as clipped_geom
      FROM %I
      WHERE label_id = $1
      AND ST_IsValid(geometry)  -- Skip invalid geometries
      AND ST_Intersects(geometry, $2)
      ORDER BY id
      LIMIT $6
      OFFSET $7
    ) sub
    WHERE NOT ST_IsEmpty(clipped_geom)
    AND ST_GeometryType(clipped_geom) IN (''ST_Polygon'', ''ST_MultiPolygon'', ''ST_GeometryCollection'')',
    p_geometry_table
  ) USING
    p_label_id,
    bbox_geom,
    bbox_geom,
    bbox_box2d,
    total_intersecting,
    p_limit,
    p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_clipped_geometries_batch(p_label_id bigint, p_geometry_table text, p_bbox_minx double precision, p_bbox_miny double precision, p_bbox_maxx double precision, p_bbox_maxy double precision, p_buffer_m double precision DEFAULT 2.0, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)
 RETURNS TABLE(geometry jsonb, total_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  bbox_geom GEOMETRY;
  bbox_box2d BOX2D;
  total_intersecting bigint;
BEGIN
  -- Create bbox geometry in EPSG:3857 with buffer
  bbox_geom := ST_MakeEnvelope(
    p_bbox_minx - p_buffer_m,
    p_bbox_miny - p_buffer_m,
    p_bbox_maxx + p_buffer_m,
    p_bbox_maxy + p_buffer_m,
    3857
  );

  -- Transform to EPSG:4326 for comparison
  bbox_geom := ST_Transform(bbox_geom, 4326);

  -- Create BOX2D for faster clipping
  bbox_box2d := bbox_geom::box2d;

  -- Get total count (only on first batch)
  -- Use ST_IsValid check to skip problematic geometries in count
  IF p_offset = 0 THEN
    EXECUTE format(
      'SELECT COUNT(*) FROM %I
       WHERE label_id = $1
       AND ST_IsValid(geometry)
       AND ST_Intersects(geometry, $2)',
      p_geometry_table
    ) INTO total_intersecting USING p_label_id, bbox_geom;
  ELSE
    total_intersecting := 0;
  END IF;

  -- Process geometries with validation BEFORE intersection check
  RETURN QUERY EXECUTE format(
    'SELECT
      ST_AsGeoJSON(
        CASE
          WHEN ST_GeometryType(clipped_geom) = ''ST_GeometryCollection''
          THEN ST_CollectionExtract(clipped_geom, 3)
          ELSE clipped_geom
        END
      )::jsonb as geometry,
      $5 as total_count
    FROM (
      SELECT
        ST_ClipByBox2D(
          -- Always validate to prevent topology exceptions
          ST_MakeValid(geometry),
          $4
        ) as clipped_geom
      FROM %I
      WHERE label_id = $1
      AND ST_IsValid(geometry)  -- Skip invalid geometries
      AND ST_Intersects(geometry, $2)
      ORDER BY id
      LIMIT $6
      OFFSET $7
    ) sub
    WHERE NOT ST_IsEmpty(clipped_geom)
    AND ST_GeometryType(clipped_geom) IN (''ST_Polygon'', ''ST_MultiPolygon'', ''ST_GeometryCollection'')',
    p_geometry_table
  ) USING
    p_label_id,
    bbox_geom,
    bbox_geom,
    bbox_box2d,
    total_intersecting,
    p_limit,
    p_offset;
END;
$function$
;

grant delete on table "public"."reference_datasets" to "anon";

grant insert on table "public"."reference_datasets" to "anon";

grant references on table "public"."reference_datasets" to "anon";

grant select on table "public"."reference_datasets" to "anon";

grant trigger on table "public"."reference_datasets" to "anon";

grant truncate on table "public"."reference_datasets" to "anon";

grant update on table "public"."reference_datasets" to "anon";

grant delete on table "public"."reference_datasets" to "authenticated";

grant insert on table "public"."reference_datasets" to "authenticated";

grant references on table "public"."reference_datasets" to "authenticated";

grant select on table "public"."reference_datasets" to "authenticated";

grant trigger on table "public"."reference_datasets" to "authenticated";

grant truncate on table "public"."reference_datasets" to "authenticated";

grant update on table "public"."reference_datasets" to "authenticated";

grant delete on table "public"."reference_datasets" to "service_role";

grant insert on table "public"."reference_datasets" to "service_role";

grant references on table "public"."reference_datasets" to "service_role";

grant select on table "public"."reference_datasets" to "service_role";

grant trigger on table "public"."reference_datasets" to "service_role";

grant truncate on table "public"."reference_datasets" to "service_role";

grant update on table "public"."reference_datasets" to "service_role";

create policy "Enable read access for all users"
on "public"."reference_datasets"
as permissive
for select
to public
using (true);



