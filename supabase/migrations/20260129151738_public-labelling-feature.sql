drop function if exists "public"."get_deadwood_vector_tiles"(z integer, x integer, y integer, filter_label_id integer, resolution integer);

drop function if exists "public"."get_deadwood_vector_tiles_debug"(z integer, x integer, y integer, resolution integer);

drop function if exists "public"."get_deadwood_vector_tiles_debug_extended"(z integer, x integer, y integer, resolution integer);

drop function if exists "public"."get_deadwood_vector_tiles_perf"(z integer, x integer, y integer, filter_label_id integer, resolution integer);

drop function if exists "public"."get_forest_cover_vector_tiles"(z integer, x integer, y integer, resolution integer);

drop function if exists "public"."get_forest_cover_vector_tiles_debug"(z integer, x integer, y integer, resolution integer);

drop function if exists "public"."get_forest_cover_vector_tiles_debug_extended"(z integer, x integer, y integer, resolution integer);

drop view if exists "public"."dataset_audit_user_info";

create table "public"."v2_geometry_corrections" (
    "id" bigint generated by default as identity not null,
    "geometry_id" bigint not null,
    "layer_type" text not null,
    "label_id" bigint not null,
    "dataset_id" bigint not null,
    "operation" text not null,
    "original_geometry_id" bigint,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "session_id" uuid not null,
    "review_status" text default 'pending'::text,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone
);


alter table "public"."v2_geometry_corrections" enable row level security;

alter table "public"."dataset_audit" add column "reviewed_at" timestamp with time zone;

alter table "public"."dataset_audit" add column "reviewed_by" uuid;

alter table "public"."v2_deadwood_geometries" add column "is_deleted" boolean default false;

alter table "public"."v2_deadwood_geometries" add column "updated_at" timestamp with time zone default now();

alter table "public"."v2_forest_cover_geometries" add column "is_deleted" boolean default false;

alter table "public"."v2_forest_cover_geometries" add column "updated_at" timestamp with time zone default now();

CREATE INDEX idx_corrections_dataset ON public.v2_geometry_corrections USING btree (dataset_id);

CREATE INDEX idx_corrections_geometry ON public.v2_geometry_corrections USING btree (geometry_id);

CREATE INDEX idx_corrections_label ON public.v2_geometry_corrections USING btree (label_id);

CREATE INDEX idx_corrections_pending ON public.v2_geometry_corrections USING btree (review_status) WHERE (review_status = 'pending'::text);

CREATE INDEX idx_corrections_session ON public.v2_geometry_corrections USING btree (session_id);

CREATE INDEX idx_corrections_user ON public.v2_geometry_corrections USING btree (user_id);

CREATE INDEX idx_dataset_audit_review ON public.dataset_audit USING btree (reviewed_at, reviewed_by) WHERE (reviewed_at IS NOT NULL);

CREATE INDEX idx_deadwood_label_is_deleted ON public.v2_deadwood_geometries USING btree (label_id, is_deleted);

CREATE INDEX idx_forest_cover_label_is_deleted ON public.v2_forest_cover_geometries USING btree (label_id, is_deleted);

CREATE UNIQUE INDEX v2_geometry_corrections_pkey ON public.v2_geometry_corrections USING btree (id);

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_pkey" PRIMARY KEY using index "v2_geometry_corrections_pkey";

alter table "public"."dataset_audit" add constraint "dataset_audit_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."dataset_audit" validate constraint "dataset_audit_reviewed_by_fkey";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_dataset_id_fkey" FOREIGN KEY (dataset_id) REFERENCES v2_datasets(id) ON DELETE CASCADE not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_dataset_id_fkey";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_label_id_fkey" FOREIGN KEY (label_id) REFERENCES v2_labels(id) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_label_id_fkey";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_layer_type_check" CHECK ((layer_type = ANY (ARRAY['deadwood'::text, 'forest_cover'::text]))) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_layer_type_check";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_operation_check" CHECK ((operation = ANY (ARRAY['add'::text, 'delete'::text, 'modify'::text]))) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_operation_check";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_review_status_check" CHECK (((review_status IS NULL) OR (review_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text])))) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_review_status_check";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_reviewed_by_fkey";

alter table "public"."v2_geometry_corrections" add constraint "v2_geometry_corrections_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."v2_geometry_corrections" validate constraint "v2_geometry_corrections_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.approve_correction(p_correction_id bigint, p_reviewer_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_correction RECORD;
BEGIN
  -- Check if user is auditor
  IF NOT EXISTS (
    SELECT 1 FROM privileged_users 
    WHERE user_id = p_reviewer_id AND can_audit = true
  ) THEN
    RAISE EXCEPTION 'User is not authorized to approve corrections';
  END IF;

  -- Get correction details
  SELECT * INTO v_correction
  FROM v2_geometry_corrections
  WHERE id = p_correction_id AND review_status = 'pending';
  
  IF NOT FOUND THEN
    RETURN false;
  END IF;

  -- Update correction status
  UPDATE v2_geometry_corrections
  SET review_status = 'approved',
      reviewed_by = p_reviewer_id,
      reviewed_at = now()
  WHERE id = p_correction_id;

  -- For 'modify' operations, soft-delete the original geometry
  IF v_correction.operation = 'modify' AND v_correction.original_geometry_id IS NOT NULL THEN
    IF v_correction.layer_type = 'deadwood' THEN
      UPDATE v2_deadwood_geometries SET is_deleted = true WHERE id = v_correction.original_geometry_id;
    ELSIF v_correction.layer_type = 'forest_cover' THEN
      UPDATE v2_forest_cover_geometries SET is_deleted = true WHERE id = v_correction.original_geometry_id;
    END IF;
  END IF;
  
  RETURN true;
END;
$function$
;

create or replace view "public"."dataset_contributor_info" as  SELECT d.id AS dataset_id,
    u.email AS contributor_email
   FROM (v2_datasets d
     LEFT JOIN auth.users u ON ((d.user_id = u.id)));


CREATE OR REPLACE FUNCTION public.get_correction_contributors(p_dataset_id bigint)
 RETURNS TABLE(user_email text, correction_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    u.email::text,
    COUNT(*)::bigint as correction_count
  FROM v2_geometry_corrections c
  JOIN auth.users u ON c.user_id = u.id
  WHERE c.dataset_id = p_dataset_id
    AND c.review_status = 'pending'
  GROUP BY u.email
  ORDER BY correction_count DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_deadwood_tiles(z integer, x integer, y integer, filter_label_id integer, resolution integer DEFAULT 4096)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 8 THEN 100000
                 WHEN z < 10 THEN 10000
                 WHEN z < 12 THEN 1000
                 WHEN z < 14 THEN 100
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'deadwood', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                256,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation
        FROM
            public.v2_deadwood_geometries g
            CROSS JOIN bbox b
            CROSS JOIN settings s
            LEFT JOIN LATERAL (
                SELECT review_status, operation 
                FROM v2_geometry_corrections 
                WHERE geometry_id = g.id AND layer_type = 'deadwood' 
                ORDER BY created_at DESC LIMIT 1
            ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.is_deleted = false
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
        LIMIT 100000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_deadwood_tiles_with_corrections(z integer, x integer, y integer, filter_label_id bigint, resolution integer DEFAULT 4096, filter_correction_status text DEFAULT NULL::text)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 8 THEN 100000
                 WHEN z < 10 THEN 10000
                 WHEN z < 12 THEN 1000
                 WHEN z < 14 THEN 100
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'deadwood', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                256,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            g.is_deleted,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation,
            c.id AS correction_id
        FROM
            public.v2_deadwood_geometries g
        CROSS JOIN bbox b
        CROSS JOIN settings s
        LEFT JOIN LATERAL (
            SELECT id, review_status, operation 
            FROM v2_geometry_corrections 
            WHERE geometry_id = g.id AND layer_type = 'deadwood'
            ORDER BY created_at DESC 
            LIMIT 1
        ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
            AND (
                CASE filter_correction_status
                    WHEN 'all' THEN true
                    WHEN 'pending' THEN c.review_status = 'pending'
                    -- Default: only show non-deleted geometries (no longer show pending deletes)
                    ELSE g.is_deleted = false
                END
            )
        LIMIT 100000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_forest_cover_tiles(z integer, x integer, y integer, filter_label_id integer, resolution integer DEFAULT 4096)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 6 THEN 1000000
                 WHEN z < 8 THEN 500000
                 WHEN z < 10 THEN 100000
                 WHEN z < 12 THEN 50000
                 WHEN z < 14 THEN 10000
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'forest_cover', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                128,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation
        FROM
            public.v2_forest_cover_geometries g
            CROSS JOIN bbox b
            CROSS JOIN settings s
            LEFT JOIN LATERAL (
                SELECT review_status, operation 
                FROM v2_geometry_corrections 
                WHERE geometry_id = g.id AND layer_type = 'forest_cover' 
                ORDER BY created_at DESC LIMIT 1
            ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.is_deleted = false
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
        LIMIT 50000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_forest_cover_tiles_with_corrections(z integer, x integer, y integer, filter_label_id bigint, resolution integer DEFAULT 4096, filter_correction_status text DEFAULT NULL::text)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 6 THEN 1000000
                 WHEN z < 8 THEN 500000
                 WHEN z < 10 THEN 100000
                 WHEN z < 12 THEN 50000
                 WHEN z < 14 THEN 10000
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'forest_cover', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                128,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            g.is_deleted,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation,
            c.id AS correction_id
        FROM
            public.v2_forest_cover_geometries g
        CROSS JOIN bbox b
        CROSS JOIN settings s
        LEFT JOIN LATERAL (
            SELECT id, review_status, operation 
            FROM v2_geometry_corrections 
            WHERE geometry_id = g.id AND layer_type = 'forest_cover'
            ORDER BY created_at DESC 
            LIMIT 1
        ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
            AND (
                CASE filter_correction_status
                    WHEN 'all' THEN true
                    WHEN 'pending' THEN c.review_status = 'pending'
                    -- Default: only show non-deleted geometries (no longer show pending deletes)
                    ELSE g.is_deleted = false
                END
            )
        LIMIT 50000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_correction_locations(p_dataset_id bigint)
 RETURNS TABLE(correction_id bigint, geometry_id bigint, layer_type text, operation text, centroid_lon double precision, centroid_lat double precision, min_lon double precision, min_lat double precision, max_lon double precision, max_lat double precision)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as correction_id,
    c.geometry_id,
    c.layer_type,
    c.operation,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_X(ST_Centroid(dg.geometry))
      ELSE ST_X(ST_Centroid(fg.geometry))
    END as centroid_lon,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_Y(ST_Centroid(dg.geometry))
      ELSE ST_Y(ST_Centroid(fg.geometry))
    END as centroid_lat,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_XMin(dg.geometry)
      ELSE ST_XMin(fg.geometry)
    END as min_lon,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_YMin(dg.geometry)
      ELSE ST_YMin(fg.geometry)
    END as min_lat,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_XMax(dg.geometry)
      ELSE ST_XMax(fg.geometry)
    END as max_lon,
    CASE 
      WHEN c.layer_type = 'deadwood' THEN ST_YMax(dg.geometry)
      ELSE ST_YMax(fg.geometry)
    END as max_lat
  FROM v2_geometry_corrections c
  LEFT JOIN v2_deadwood_geometries dg ON c.geometry_id = dg.id AND c.layer_type = 'deadwood'
  LEFT JOIN v2_forest_cover_geometries fg ON c.geometry_id = fg.id AND c.layer_type = 'forest_cover'
  WHERE c.dataset_id = p_dataset_id
    AND c.review_status = 'pending'
  ORDER BY c.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.revert_correction(p_correction_id bigint, p_reviewer_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_correction RECORD;
  v_table_name TEXT;
BEGIN
  -- Check if user is auditor
  IF NOT EXISTS (
    SELECT 1 FROM privileged_users 
    WHERE user_id = p_reviewer_id AND can_audit = true
  ) THEN
    RAISE EXCEPTION 'User is not authorized to revert corrections';
  END IF;

  -- Get correction details
  SELECT * INTO v_correction FROM v2_geometry_corrections WHERE id = p_correction_id;
  
  IF NOT FOUND THEN
    RETURN false;
  END IF;
  
  IF v_correction.review_status != 'pending' THEN
    RAISE EXCEPTION 'Can only revert pending corrections';
  END IF;
  
  IF v_correction.layer_type = 'deadwood' THEN
    v_table_name := 'v2_deadwood_geometries';
  ELSE
    v_table_name := 'v2_forest_cover_geometries';
  END IF;

  -- Handle based on operation type
  CASE v_correction.operation
    WHEN 'delete' THEN
      -- Restore the deleted geometry
      EXECUTE format('UPDATE %I SET is_deleted = false WHERE id = $1', v_table_name)
        USING v_correction.geometry_id;
    WHEN 'add' THEN
      -- Hard delete the added geometry (it was never approved)
      EXECUTE format('DELETE FROM %I WHERE id = $1', v_table_name)
        USING v_correction.geometry_id;
    WHEN 'modify' THEN
      -- Delete new geometry, restore original
      EXECUTE format('DELETE FROM %I WHERE id = $1', v_table_name)
        USING v_correction.geometry_id;
      IF v_correction.original_geometry_id IS NOT NULL THEN
        EXECUTE format('UPDATE %I SET is_deleted = false WHERE id = $1', v_table_name)
          USING v_correction.original_geometry_id;
      END IF;
  END CASE;

  -- Mark correction as rejected (kept for audit trail)
  UPDATE v2_geometry_corrections
  SET review_status = 'rejected',
      reviewed_by = p_reviewer_id,
      reviewed_at = now()
  WHERE id = p_correction_id;
  
  RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.save_prediction_corrections(p_dataset_id bigint, p_label_id bigint, p_user_id uuid, p_layer_type text, p_session_id uuid, p_deletions bigint[], p_deletion_timestamps timestamp with time zone[], p_additions jsonb)
 RETURNS TABLE(success boolean, message text, conflict_ids bigint[])
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_table_name TEXT;
  v_conflict_ids BIGINT[] := '{}';
  v_deletion_id BIGINT;
  v_expected_ts TIMESTAMPTZ;
  v_actual_ts TIMESTAMPTZ;
  v_geometry JSONB;
  v_new_id BIGINT;
  v_original_id BIGINT;
  v_is_pending_from_other BOOLEAN;
  i INTEGER;
BEGIN
  -- SECURITY: Verify caller is the user they claim to be
  IF p_user_id != auth.uid() THEN
    RETURN QUERY SELECT false, 'Cannot save corrections for another user'::TEXT, NULL::BIGINT[];
    RETURN;
  END IF;

  -- Validate layer type
  IF p_layer_type NOT IN ('deadwood', 'forest_cover') THEN
    RETURN QUERY SELECT false, 'Invalid layer_type'::TEXT, NULL::BIGINT[];
    RETURN;
  END IF;

  -- Determine table
  IF p_layer_type = 'deadwood' THEN
    v_table_name := 'v2_deadwood_geometries';
  ELSE
    v_table_name := 'v2_forest_cover_geometries';
  END IF;

  -- Process deletions with optimistic locking
  IF p_deletions IS NOT NULL AND array_length(p_deletions, 1) > 0 THEN
    FOR i IN 1..array_length(p_deletions, 1) LOOP
      v_deletion_id := p_deletions[i];
      v_expected_ts := p_deletion_timestamps[i];
      
      -- Check timestamp matches (optimistic lock)
      EXECUTE format('SELECT updated_at FROM %I WHERE id = $1', v_table_name)
        INTO v_actual_ts USING v_deletion_id;
      
      IF v_actual_ts IS NULL THEN
        -- Geometry doesn't exist
        v_conflict_ids := array_append(v_conflict_ids, v_deletion_id);
        CONTINUE;
      END IF;
      
      IF v_actual_ts != v_expected_ts THEN
        v_conflict_ids := array_append(v_conflict_ids, v_deletion_id);
        CONTINUE;
      END IF;
      
      -- Check if this is another user's pending correction (block editing)
      SELECT EXISTS (
        SELECT 1 FROM v2_geometry_corrections 
        WHERE geometry_id = v_deletion_id 
        AND layer_type = p_layer_type
        AND operation = 'add' 
        AND review_status = 'pending'
        AND user_id != p_user_id
      ) INTO v_is_pending_from_other;
      
      IF v_is_pending_from_other THEN
        RETURN QUERY SELECT false, 'Cannot modify another user''s pending correction'::TEXT, ARRAY[v_deletion_id];
        RETURN;
      END IF;
      
      -- Mark as deleted
      EXECUTE format('UPDATE %I SET is_deleted = true WHERE id = $1', v_table_name)
        USING v_deletion_id;
      
      -- Record in history
      INSERT INTO v2_geometry_corrections 
        (geometry_id, layer_type, label_id, dataset_id, operation, user_id, session_id)
      VALUES 
        (v_deletion_id, p_layer_type, p_label_id, p_dataset_id, 'delete', p_user_id, p_session_id);
    END LOOP;
  END IF;

  -- If any conflicts, abort
  IF array_length(v_conflict_ids, 1) > 0 THEN
    RETURN QUERY SELECT false, 'Conflict detected - some geometries were modified by another user'::TEXT, v_conflict_ids;
    RETURN;
  END IF;

  -- Process additions
  IF p_additions IS NOT NULL AND jsonb_array_length(p_additions) > 0 THEN
    FOR v_geometry IN SELECT * FROM jsonb_array_elements(p_additions)
    LOOP
      -- Get original_geometry_id if this is a modify operation
      v_original_id := (v_geometry->>'original_geometry_id')::BIGINT;
      
      -- Insert new geometry
      EXECUTE format(
        'INSERT INTO %I (label_id, geometry) VALUES ($1, ST_GeomFromGeoJSON($2)) RETURNING id',
        v_table_name
      ) INTO v_new_id USING p_label_id, v_geometry->>'geometry';
      
      -- Record in history
      INSERT INTO v2_geometry_corrections 
        (geometry_id, layer_type, label_id, dataset_id, operation, original_geometry_id, user_id, session_id)
      VALUES 
        (v_new_id, p_layer_type, p_label_id, p_dataset_id, 
         CASE WHEN v_original_id IS NOT NULL THEN 'modify' ELSE 'add' END,
         v_original_id, p_user_id, p_session_id);
      
      -- For modify operations, immediately soft-delete the original geometry
      -- This prevents the "dual layer" issue where both old and new are visible
      IF v_original_id IS NOT NULL THEN
        EXECUTE format('UPDATE %I SET is_deleted = true WHERE id = $1', v_table_name)
          USING v_original_id;
      END IF;
    END LOOP;
  END IF;

  RETURN QUERY SELECT true, 'Success'::TEXT, NULL::BIGINT[];
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_geometry_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

create or replace view "public"."dataset_audit_user_info" as  SELECT da.dataset_id,
    da.audit_date,
    da.is_georeferenced,
    da.has_valid_acquisition_date,
    da.acquisition_date_notes,
    da.has_valid_phenology,
    da.phenology_notes,
    da.deadwood_quality,
    da.deadwood_notes,
    da.forest_cover_quality,
    da.forest_cover_notes,
    da.aoi_done,
    da.has_cog_issue,
    da.cog_issue_notes,
    da.has_thumbnail_issue,
    da.thumbnail_issue_notes,
    da.audited_by,
    da.notes,
    da.has_major_issue,
    da.final_assessment,
    da.reviewed_at,
    da.reviewed_by,
    au.email AS audited_by_email,
    uu.email AS uploaded_by_email,
    ru.email AS reviewed_by_email
   FROM ((((dataset_audit da
     LEFT JOIN auth.users au ON ((da.audited_by = au.id)))
     LEFT JOIN v2_datasets d ON ((da.dataset_id = d.id)))
     LEFT JOIN auth.users uu ON ((d.user_id = uu.id)))
     LEFT JOIN auth.users ru ON ((da.reviewed_by = ru.id)));


CREATE OR REPLACE FUNCTION public.get_deadwood_vector_tiles_perf1(z integer, x integer, y integer, filter_label_id integer, resolution integer DEFAULT 4096)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 8 THEN 100000
                 WHEN z < 10 THEN 10000
                 WHEN z < 12 THEN 1000
                 WHEN z < 14 THEN 100
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'deadwood', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                256,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation
        FROM
            public.v2_deadwood_geometries g
            CROSS JOIN bbox b
            CROSS JOIN settings s
            LEFT JOIN LATERAL (
                SELECT review_status, operation 
                FROM v2_geometry_corrections 
                WHERE geometry_id = g.id AND layer_type = 'deadwood' 
                ORDER BY created_at DESC LIMIT 1
            ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.is_deleted = false
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
        LIMIT 100000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_forest_cover_vector_tiles_perf(z integer, x integer, y integer, filter_label_id integer, resolution integer DEFAULT 4096)
 RETURNS text
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    mvt bytea;
BEGIN
    WITH
    bbox AS (
        SELECT ST_TileEnvelope(z, x, y) AS bbox_3857
    ),
    settings AS (
        SELECT
            CASE WHEN z < 6 THEN 1000000
                 WHEN z < 8 THEN 500000
                 WHEN z < 10 THEN 100000
                 WHEN z < 12 THEN 50000
                 WHEN z < 14 THEN 10000
                 ELSE 0 END AS min_area
    )
    SELECT ST_AsMVT(tile_data, 'forest_cover', resolution)
    INTO mvt
    FROM (
        SELECT
            ST_AsMVTGeom(
                ST_Transform(g.geometry, 3857),
                b.bbox_3857,
                resolution,
                128,
                true
            ) AS geom,
            g.id,
            g.label_id,
            g.properties,
            COALESCE(c.review_status, 'original') AS correction_status,
            c.operation AS correction_operation
        FROM
            public.v2_forest_cover_geometries g
            CROSS JOIN bbox b
            CROSS JOIN settings s
            LEFT JOIN LATERAL (
                SELECT review_status, operation 
                FROM v2_geometry_corrections 
                WHERE geometry_id = g.id AND layer_type = 'forest_cover' 
                ORDER BY created_at DESC LIMIT 1
            ) c ON true
        WHERE
            g.label_id = filter_label_id
            AND g.is_deleted = false
            AND g.area_m2 >= s.min_area
            AND g.geometry && ST_Transform(b.bbox_3857, ST_SRID(g.geometry))
            AND ST_Intersects(g.geometry, ST_Transform(b.bbox_3857, ST_SRID(g.geometry)))
        LIMIT 50000
    ) AS tile_data
    WHERE tile_data.geom IS NOT NULL;

    RETURN encode(mvt, 'base64');
END;
$function$
;

create or replace view "public"."v2_full_dataset_view" as  WITH ds AS (
         SELECT v2_datasets.id,
            v2_datasets.user_id,
            v2_datasets.created_at,
            v2_datasets.file_name,
            v2_datasets.license,
            v2_datasets.platform,
            v2_datasets.project_id,
            v2_datasets.authors,
            v2_datasets.aquisition_year,
            v2_datasets.aquisition_month,
            v2_datasets.aquisition_day,
            v2_datasets.additional_information,
            v2_datasets.data_access,
            v2_datasets.citation_doi
           FROM v2_datasets
          WHERE ((v2_datasets.data_access <> 'private'::access) OR (auth.uid() = v2_datasets.user_id) OR can_view_all_private_data())
        ), ortho AS (
         SELECT v2_orthos.dataset_id,
            v2_orthos.ortho_file_name,
            v2_orthos.ortho_file_size,
            v2_orthos.bbox,
            v2_orthos.sha256,
            v2_orthos.ortho_upload_runtime
           FROM v2_orthos
        ), status AS (
         SELECT v2_statuses.dataset_id,
            v2_statuses.current_status,
            v2_statuses.is_upload_done,
            v2_statuses.is_ortho_done,
            v2_statuses.is_cog_done,
            v2_statuses.is_thumbnail_done,
            v2_statuses.is_deadwood_done,
            v2_statuses.is_forest_cover_done,
            v2_statuses.is_metadata_done,
            v2_statuses.is_odm_done,
            (EXISTS ( SELECT 1
                   FROM dataset_audit da
                  WHERE (da.dataset_id = v2_statuses.dataset_id))) AS is_audited,
            v2_statuses.has_error,
            v2_statuses.error_message,
            v2_statuses.has_ml_tiles,
            v2_statuses.ml_tiles_completed_at
           FROM v2_statuses
        ), extra AS (
         SELECT ds_1.id AS dataset_id,
            cog.cog_file_name,
            cog.cog_path,
            cog.cog_file_size,
            thumb.thumbnail_file_name,
            thumb.thumbnail_path,
            (meta.metadata ->> 'gadm'::text) AS admin_metadata,
            (meta.metadata ->> 'biome'::text) AS biome_metadata
           FROM (((v2_datasets ds_1
             LEFT JOIN v2_cogs cog ON ((cog.dataset_id = ds_1.id)))
             LEFT JOIN v2_thumbnails thumb ON ((thumb.dataset_id = ds_1.id)))
             LEFT JOIN v2_metadata meta ON ((meta.dataset_id = ds_1.id)))
          WHERE ((ds_1.data_access <> 'private'::access) OR (auth.uid() = ds_1.user_id) OR can_view_all_private_data())
        ), label_info AS (
         SELECT dataset.id AS dataset_id,
            (EXISTS ( SELECT 1
                   FROM v2_labels
                  WHERE ((v2_labels.dataset_id = dataset.id) AND (v2_labels.label_source = 'visual_interpretation'::"LabelSource") AND (v2_labels.label_data = 'deadwood'::"LabelData")))) AS has_labels,
            (EXISTS ( SELECT 1
                   FROM v2_labels
                  WHERE ((v2_labels.dataset_id = dataset.id) AND (v2_labels.label_source = 'model_prediction'::"LabelSource") AND (v2_labels.label_data = 'deadwood'::"LabelData")))) AS has_deadwood_prediction
           FROM v2_datasets dataset
          WHERE ((dataset.data_access <> 'private'::access) OR (auth.uid() = dataset.user_id) OR can_view_all_private_data())
        ), freidata_doi AS (
         SELECT jt.dataset_id,
            dp.doi AS freidata_doi
           FROM (jt_data_publication_datasets jt
             JOIN data_publication dp ON ((dp.id = jt.publication_id)))
          WHERE (dp.doi IS NOT NULL)
        ), correction_stats AS (
         SELECT gc.dataset_id,
            count(*) FILTER (WHERE (gc.review_status = 'pending'::text)) AS pending_corrections_count,
            count(*) FILTER (WHERE (gc.review_status = 'approved'::text)) AS approved_corrections_count,
            count(*) FILTER (WHERE (gc.review_status = 'rejected'::text)) AS rejected_corrections_count,
            count(*) AS total_corrections_count
           FROM v2_geometry_corrections gc
          GROUP BY gc.dataset_id
        )
 SELECT ds.id,
    ds.user_id,
    ds.created_at,
    ds.file_name,
    ds.license,
    ds.platform,
    ds.project_id,
    ds.authors,
    ds.aquisition_year,
    ds.aquisition_month,
    ds.aquisition_day,
    ds.additional_information,
    ds.data_access,
    ds.citation_doi,
    ortho.ortho_file_name,
    ortho.ortho_file_size,
    ortho.bbox,
    ortho.sha256,
    status.current_status,
    status.is_upload_done,
    status.is_ortho_done,
    status.is_cog_done,
    status.is_thumbnail_done,
    status.is_deadwood_done,
    status.is_forest_cover_done,
    status.is_metadata_done,
    status.is_odm_done,
    status.is_audited,
    status.has_error,
    status.error_message,
    extra.cog_file_name,
    extra.cog_path,
    extra.cog_file_size,
    extra.thumbnail_file_name,
    extra.thumbnail_path,
    ((extra.admin_metadata)::jsonb ->> 'admin_level_1'::text) AS admin_level_1,
    ((extra.admin_metadata)::jsonb ->> 'admin_level_2'::text) AS admin_level_2,
    ((extra.admin_metadata)::jsonb ->> 'admin_level_3'::text) AS admin_level_3,
    ((extra.biome_metadata)::jsonb ->> 'biome_name'::text) AS biome_name,
    label_info.has_labels,
    label_info.has_deadwood_prediction,
    freidata_doi.freidata_doi,
    status.has_ml_tiles,
    status.ml_tiles_completed_at,
    COALESCE(correction_stats.pending_corrections_count, (0)::bigint) AS pending_corrections_count,
    COALESCE(correction_stats.approved_corrections_count, (0)::bigint) AS approved_corrections_count,
    COALESCE(correction_stats.rejected_corrections_count, (0)::bigint) AS rejected_corrections_count,
    COALESCE(correction_stats.total_corrections_count, (0)::bigint) AS total_corrections_count
   FROM ((((((ds
     LEFT JOIN ortho ON ((ortho.dataset_id = ds.id)))
     LEFT JOIN status ON ((status.dataset_id = ds.id)))
     LEFT JOIN extra ON ((extra.dataset_id = ds.id)))
     LEFT JOIN label_info ON ((label_info.dataset_id = ds.id)))
     LEFT JOIN freidata_doi ON ((freidata_doi.dataset_id = ds.id)))
     LEFT JOIN correction_stats ON ((correction_stats.dataset_id = ds.id)));


create or replace view "public"."v2_processing_overview" as  SELECT DISTINCT ON (d.id) d.id AS dataset_id,
    d.file_name,
    d.created_at AS dataset_created_at,
        CASE
            WHEN ((COALESCE(ri.raw_image_count, 0) > 0) OR s.is_odm_done) THEN 'odm'::text
            ELSE 'geotiff'::text
        END AS processing_source,
        CASE
            WHEN ((s.current_status <> 'idle'::v2_status) AND (s.has_error IS DISTINCT FROM true)) THEN 'PROCESSING'::text
            WHEN (EXISTS ( SELECT 1
               FROM v2_queue q
              WHERE (q.dataset_id = d.id))) THEN 'QUEUED'::text
            WHEN s.has_error THEN 'FAILED'::text
            ELSE 'COMPLETED'::text
        END AS processing_status,
    s.current_status,
    s.has_error,
    s.error_message,
    (EXTRACT(epoch FROM (now() - s.updated_at)) / (3600)::numeric) AS hours_since_status_update,
        CASE
            WHEN (s.current_status <> 'idle'::v2_status) THEN (EXTRACT(epoch FROM (now() - s.updated_at)) / (3600)::numeric)
            ELSE NULL::numeric
        END AS hours_in_current_status,
    s.updated_at AS status_last_updated,
    (EXISTS ( SELECT 1
           FROM v2_queue q
          WHERE (q.dataset_id = d.id))) AS is_in_queue,
    ( SELECT min(q.created_at) AS min
           FROM v2_queue q
          WHERE (q.dataset_id = d.id)) AS queued_at,
    ( SELECT min(q.priority) AS min
           FROM v2_queue q
          WHERE (q.dataset_id = d.id)) AS queue_priority,
    au.email AS user_email,
    ui.organisation,
    s.is_upload_done,
    s.is_ortho_done,
    s.is_cog_done,
    s.is_thumbnail_done,
    s.is_deadwood_done,
    s.is_forest_cover_done,
    s.is_metadata_done,
    s.is_odm_done,
    (EXISTS ( SELECT 1
           FROM dataset_audit da
          WHERE (da.dataset_id = d.id))) AS is_audited,
    ( SELECT count(*) AS count
           FROM v2_aois a
          WHERE (a.dataset_id = d.id)) AS aoi_count,
    ( SELECT count(dg.id) AS count
           FROM (v2_labels l
             LEFT JOIN v2_deadwood_geometries dg ON ((dg.label_id = l.id)))
          WHERE (l.dataset_id = d.id)) AS deadwood_geometry_count,
    ( SELECT count(fg.id) AS count
           FROM (v2_labels l
             LEFT JOIN v2_forest_cover_geometries fg ON ((fg.label_id = l.id)))
          WHERE (l.dataset_id = d.id)) AS forest_cover_geometry_count,
    ri.raw_images_path,
    ri.raw_image_count,
    ri.raw_image_size_mb,
    o.ortho_file_size,
    c.cog_file_size,
    COALESCE((((o.ortho_info -> 'Profile'::text) ->> 'Width'::text))::integer, ((o.ortho_info ->> 'Width'::text))::integer) AS ortho_width,
    COALESCE((((o.ortho_info -> 'Profile'::text) ->> 'Height'::text))::integer, ((o.ortho_info ->> 'Height'::text))::integer) AS ortho_height,
    ((o.ortho_info -> 'GEO'::text) ->> 'CRS'::text) AS ortho_crs,
    ((c.cog_info -> 'GEO'::text) ->> 'CRS'::text) AS cog_crs,
    jsonb_strip_nulls((COALESCE(ri.camera_metadata, '{}'::jsonb) || jsonb_build_object('has_rtk_data', ri.has_rtk_data, 'rtk_precision_cm', ri.rtk_precision_cm, 'rtk_quality_indicator', ri.rtk_quality_indicator, 'rtk_file_count', ri.rtk_file_count))) AS raw_images_metadata,
    o.ortho_info AS ortho_metadata,
    c.cog_info AS cog_metadata,
    ( SELECT string_agg(((((((recent_logs.level || '|'::text) || COALESCE(recent_logs.category, 'general'::text)) || '|'::text) || to_char(recent_logs.created_at, 'MM-DD HH24:MI'::text)) || '|'::text) || "substring"(recent_logs.message, 1, 100)), chr(10) ORDER BY recent_logs.created_at DESC) AS string_agg
           FROM ( SELECT v2_logs.level,
                    v2_logs.category,
                    v2_logs.message,
                    v2_logs.created_at
                   FROM v2_logs
                  WHERE (v2_logs.dataset_id = d.id)
                  ORDER BY v2_logs.created_at DESC
                 LIMIT 20) recent_logs) AS last_20_logs
   FROM ((((((v2_datasets d
     LEFT JOIN v2_statuses s ON ((s.dataset_id = d.id)))
     LEFT JOIN auth.users au ON ((au.id = d.user_id)))
     LEFT JOIN user_info ui ON ((ui."user" = d.user_id)))
     LEFT JOIN LATERAL ( SELECT o_1.dataset_id,
            o_1.ortho_file_name,
            o_1.version,
            o_1.created_at,
            o_1.bbox,
            o_1.sha256,
            o_1.ortho_upload_runtime,
            o_1.ortho_file_size,
            o_1.ortho_info
           FROM v2_orthos o_1
          WHERE (o_1.dataset_id = d.id)
          ORDER BY o_1.created_at DESC, o_1.version DESC
         LIMIT 1) o ON (true))
     LEFT JOIN LATERAL ( SELECT c_1.dataset_id,
            c_1.cog_file_name,
            c_1.version,
            c_1.created_at,
            c_1.cog_info,
            c_1.cog_processing_runtime,
            c_1.cog_path,
            c_1.cog_file_size
           FROM v2_cogs c_1
          WHERE (c_1.dataset_id = d.id)
          ORDER BY c_1.created_at DESC, c_1.version DESC
         LIMIT 1) c ON (true))
     LEFT JOIN LATERAL ( SELECT ri_1.dataset_id,
            ri_1.raw_image_count,
            ri_1.raw_image_size_mb,
            ri_1.raw_images_path,
            ri_1.camera_metadata,
            ri_1.has_rtk_data,
            ri_1.rtk_precision_cm,
            ri_1.rtk_quality_indicator,
            ri_1.rtk_file_count,
            ri_1.version,
            ri_1.created_at
           FROM v2_raw_images ri_1
          WHERE (ri_1.dataset_id = d.id)
          ORDER BY ri_1.created_at DESC, ri_1.version DESC
         LIMIT 1) ri ON (true))
  ORDER BY d.id DESC, COALESCE(s.updated_at, d.created_at) DESC
 LIMIT 100;


grant delete on table "public"."v2_geometry_corrections" to "anon";

grant insert on table "public"."v2_geometry_corrections" to "anon";

grant references on table "public"."v2_geometry_corrections" to "anon";

grant select on table "public"."v2_geometry_corrections" to "anon";

grant trigger on table "public"."v2_geometry_corrections" to "anon";

grant truncate on table "public"."v2_geometry_corrections" to "anon";

grant update on table "public"."v2_geometry_corrections" to "anon";

grant delete on table "public"."v2_geometry_corrections" to "authenticated";

grant insert on table "public"."v2_geometry_corrections" to "authenticated";

grant references on table "public"."v2_geometry_corrections" to "authenticated";

grant select on table "public"."v2_geometry_corrections" to "authenticated";

grant trigger on table "public"."v2_geometry_corrections" to "authenticated";

grant truncate on table "public"."v2_geometry_corrections" to "authenticated";

grant update on table "public"."v2_geometry_corrections" to "authenticated";

grant delete on table "public"."v2_geometry_corrections" to "service_role";

grant insert on table "public"."v2_geometry_corrections" to "service_role";

grant references on table "public"."v2_geometry_corrections" to "service_role";

grant select on table "public"."v2_geometry_corrections" to "service_role";

grant trigger on table "public"."v2_geometry_corrections" to "service_role";

grant truncate on table "public"."v2_geometry_corrections" to "service_role";

grant update on table "public"."v2_geometry_corrections" to "service_role";

create policy "Authenticated insert corrections"
on "public"."v2_geometry_corrections"
as permissive
for insert
to authenticated
with check (true);


create policy "Public read corrections"
on "public"."v2_geometry_corrections"
as permissive
for select
to public
using (true);


CREATE TRIGGER trg_deadwood_updated_at BEFORE UPDATE ON public.v2_deadwood_geometries FOR EACH ROW EXECUTE FUNCTION update_geometry_timestamp();

CREATE TRIGGER trg_forest_cover_updated_at BEFORE UPDATE ON public.v2_forest_cover_geometries FOR EACH ROW EXECUTE FUNCTION update_geometry_timestamp();


